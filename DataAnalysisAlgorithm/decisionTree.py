import numpy as np

# 信息熵，表示信息的不确定度
# Entropy(t)=-∑p(i|t)log2p(i|t)
# 例如集合1:5次去打篮球，1次不去；集合2:3次去打篮球，3次不打

E1 = -5 / 6 * np.log2(5 / 6) - 1 / 6 * np.log2(1 / 6)
E2 = -3 / 6 * np.log2(3 / 6) - 3 / 6 * np.log2(3 / 6)
print(E1, E2)  # 0.6500224216483541 1.0
# 信息熵越大，纯度越低

# ID3，计算信息增益
# Gain(D,a)=Entropy(D)-∑|Di|/|D|Entropy(Di)
# 公式中 D 是父亲节点，Di 是子节点，Gain(D,a) 中的 a 作为 D 节点的属性选择

# 3打4不打
E_D = -3 / 7 * np.log2(3 / 7) - 4 / 7 * np.log2(4 / 7)
# D1(天气 = 晴天)={1-,2-,6+}
# D2(天气 = 阴天)={3+,7-}
# D3(天气 = 小雨)={4+,5-}
E_D1 = -2 / 3 * np.log2(2 / 3) - 1 / 3 * np.log2(1 / 3)
E_D2 = -1 / 2 * np.log2(1 / 2) - 1 / 2 * np.log2(1 / 2)
E_D3 = -1 / 2 * np.log2(1 / 2) - 1 / 2 * np.log2(1 / 2)
G_weather = E_D - (3 / 7 * E_D1 + 2 / 7 * E_D2 + 2 / 7 * E_D3)
print(G_weather)

# D1(温度 = 高)={1-,2-,3+,4+}
# D2(温度 = 中)={6+,7-}
# D3(温度 = 低)={5-}
E_D1 = -2 / 4 * np.log2(2 / 4) - 2 / 4 * np.log2(2 / 4)
E_D2 = -1 / 2 * np.log2(1 / 2) - 1 / 2 * np.log2(1 / 2)
E_D3 = -1 / 1 * np.log2(1 / 1)
G_temperature = E_D - (4 / 7 * E_D1 + 2 / 7 * E_D2 + 1 / 7 * E_D3)
print(G_temperature)

# 3打4不打
# D1(湿度 = 高)={3+,4+,5-,7-}
# D2(湿度 = 中)={1-,2-,6+}
E_D1 = -2 / 4 * np.log2(2 / 4) - 2 / 4 * np.log2(2 / 4)
E_D2 = -1 / 3 * np.log2(1 / 3) - 2 / 3 * np.log2(2 / 3)
G_humidity = E_D - (4 / 7 * E_D1 + 3 / 7 * E_D2)
print(G_humidity)

# D1(刮风 = 是)={1-,3+,4+,5-}
# D2(刮风 = 否)={2-,6+,7-}
E_D1 = -2 / 4 * np.log2(2 / 4) - 2 / 4 * np.log2(2 / 4)
E_D2 = -1 / 3 * np.log2(1 / 3) - 2 / 3 * np.log2(2 / 3)
G_windy = E_D - (4 / 7 * E_D1 + 3 / 7 * E_D2)
print(G_windy)

# G_temperature最大，作为根节点
# 进一步进行分裂，往下划分，计算其不同属性（天气、湿度、刮风）作为节点的信息增益
# 温度 = 高时，{1-,2-,3+,4+}
E_D = -1/2 * np.log2(1/2) - 1/2 * np.log2(1/2)
# D1(天气 = 晴天)={1-,2-}
# D2(天气 = 阴天)={3+}
# D3(天气 = 小雨)={4+}
E_D1 = -2/2 * np.log2(2/2)
E_D2 = -1/1 * np.log2(1/1)
E_D3 = -1/1 * np.log2(1/1)
G_temperature_high_weather = E_D - (2/4*E_D1 + 1/4*E_D2 + 1/4*E_D3)
print(G_temperature_high_weather)
# ID3 的算法规则相对简单，可解释性强。同样也存在缺陷，比如我们会发现 ID3 算法倾向于选择取值比较多的属性
# 所以 ID3 有一个缺陷就是，有些属性可能对分类任务没有太大作用，但是他们仍然可能会被选为最优属性

# C4.5相对ID3改进：
# 1.采用信息增益率
# 2.采用悲观剪枝
# 3.离散化处理连续属性
# 4.处理缺失值



